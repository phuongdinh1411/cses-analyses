# CSES Road Reparation - Problem Analysis

## Problem Statement
Given a graph with n cities and m roads, find the minimum cost to repair roads so that all cities are connected. Each road has a repair cost.

### Input
The first input line has two integers n and m: the number of cities and roads.
Then there are m lines describing the roads. Each line has three integers a, b, and c: there is a road between cities a and b with repair cost c.

### Output
Print the minimum cost to repair roads so that all cities are connected, or "IMPOSSIBLE" if it's not possible.

### Constraints
- 1 ≤ n ≤ 10^5
- 1 ≤ m ≤ 2⋅10^5
- 1 ≤ a,b ≤ n
- 1 ≤ c ≤ 10^9

### Example
```
Input:
4 4
1 2 1
2 3 2
3 4 3
1 4 4

Output:
6
```

## Solution Progression

### Approach 1: Kruskal's Algorithm - O(m log m)
**Description**: Use Kruskal's algorithm to find minimum spanning tree.

```python
def road_reparation_naive(n, m, roads):
    # Sort roads by cost
    roads.sort(key=lambda x: x[2])
    
    # Union-Find for cycle detection
    parent = list(range(n + 1))
    
    def find(x):
        if parent[x] != x:
            parent[x] = find(parent[x])
        return parent[x]
    
    def union(x, y):
        parent[find(x)] = find(y)
    
    # Kruskal's algorithm
    total_cost = 0
    edges_used = 0
    
    for a, b, cost in roads:
        if find(a) != find(b):
            union(a, b)
            total_cost += cost
            edges_used += 1
    
    # Check if all cities are connected
    if edges_used == n - 1:
        return total_cost
    else:
        return "IMPOSSIBLE"
```

**Why this is inefficient**: The implementation is correct but can be optimized for clarity.

### Improvement 1: Optimized Kruskal's Algorithm - O(m log m)
**Description**: Use optimized Kruskal's algorithm with better Union-Find.

```python
def road_reparation_optimized(n, m, roads):
    # Sort roads by cost
    roads.sort(key=lambda x: x[2])
    
    # Union-Find with path compression and union by rank
    parent = list(range(n + 1))
    rank = [0] * (n + 1)
    
    def find(x):
        if parent[x] != x:
            parent[x] = find(parent[x])
        return parent[x]
    
    def union(x, y):
        px, py = find(x), find(y)
        if px == py:
            return False
        
        if rank[px] < rank[py]:
            parent[px] = py
        elif rank[px] > rank[py]:
            parent[py] = px
        else:
            parent[py] = px
            rank[px] += 1
        return True
    
    # Kruskal's algorithm
    total_cost = 0
    edges_used = 0
    
    for a, b, cost in roads:
        if union(a, b):
            total_cost += cost
            edges_used += 1
    
    # Check if all cities are connected
    if edges_used == n - 1:
        return total_cost
    else:
        return "IMPOSSIBLE"
```

**Why this improvement works**: We use Kruskal's algorithm with optimized Union-Find to find the minimum spanning tree efficiently.

## Final Optimal Solution

```python
n, m = map(int, input().split())
roads = []
for _ in range(m):
    a, b, c = map(int, input().split())
    roads.append((a, b, c))

def find_minimum_repair_cost(n, m, roads):
    # Sort roads by cost
    roads.sort(key=lambda x: x[2])
    
    # Union-Find with path compression and union by rank
    parent = list(range(n + 1))
    rank = [0] * (n + 1)
    
    def find(x):
        if parent[x] != x:
            parent[x] = find(parent[x])
        return parent[x]
    
    def union(x, y):
        px, py = find(x), find(y)
        if px == py:
            return False
        
        if rank[px] < rank[py]:
            parent[px] = py
        elif rank[px] > rank[py]:
            parent[py] = px
        else:
            parent[py] = px
            rank[px] += 1
        return True
    
    # Kruskal's algorithm
    total_cost = 0
    edges_used = 0
    
    for a, b, cost in roads:
        if union(a, b):
            total_cost += cost
            edges_used += 1
    
    # Check if all cities are connected
    if edges_used == n - 1:
        return total_cost
    else:
        return "IMPOSSIBLE"

result = find_minimum_repair_cost(n, m, roads)
print(result)
```

## Complexity Analysis

| Approach | Time Complexity | Space Complexity | Key Insight |
|----------|----------------|------------------|-------------|
| Kruskal's Algorithm | O(m log m) | O(n) | Use Kruskal's for minimum spanning tree |
| Optimized Kruskal's | O(m log m) | O(n) | Optimized Union-Find implementation |

## Key Insights for Other Problems

### 1. **Minimum Spanning Tree**
**Principle**: Use Kruskal's or Prim's algorithm to find minimum spanning tree.
**Applicable to**: MST problems, connectivity problems, optimization problems

### 2. **Kruskal's Algorithm**
**Principle**: Sort edges by weight and add them if they don't create cycles.
**Applicable to**: MST problems, graph problems, optimization problems

### 3. **Union-Find Optimization**
**Principle**: Use path compression and union by rank for efficient Union-Find operations.
**Applicable to**: Union-Find problems, connectivity problems, graph problems

## Notable Techniques

### 1. **Kruskal's Algorithm Implementation**
```python
def kruskal_algorithm(n, edges):
    # Sort edges by weight
    edges.sort(key=lambda x: x[2])
    
    # Union-Find
    parent = list(range(n + 1))
    rank = [0] * (n + 1)
    
    def find(x):
        if parent[x] != x:
            parent[x] = find(parent[x])
        return parent[x]
    
    def union(x, y):
        px, py = find(x), find(y)
        if px == py:
            return False
        
        if rank[px] < rank[py]:
            parent[px] = py
        elif rank[px] > rank[py]:
            parent[py] = px
        else:
            parent[py] = px
            rank[px] += 1
        return True
    
    # Build MST
    total_cost = 0
    edges_used = 0
    
    for a, b, cost in edges:
        if union(a, b):
            total_cost += cost
            edges_used += 1
    
    return total_cost if edges_used == n - 1 else "IMPOSSIBLE"
```

### 2. **Union-Find with Path Compression**
```python
def union_find(n):
    parent = list(range(n + 1))
    rank = [0] * (n + 1)
    
    def find(x):
        if parent[x] != x:
            parent[x] = find(parent[x])
        return parent[x]
    
    def union(x, y):
        px, py = find(x), find(y)
        if px == py:
            return False
        
        if rank[px] < rank[py]:
            parent[px] = py
        elif rank[px] > rank[py]:
            parent[py] = px
        else:
            parent[py] = px
            rank[px] += 1
        return True
    
    return find, union
```

### 3. **Edge Sorting**
```python
def sort_edges_by_weight(edges):
    return sorted(edges, key=lambda x: x[2])
```

## Problem-Solving Framework

1. **Identify problem type**: This is a minimum spanning tree problem
2. **Choose approach**: Use Kruskal's algorithm
3. **Sort edges**: Sort edges by weight in ascending order
4. **Initialize Union-Find**: Set up Union-Find data structure
5. **Process edges**: Add edges that don't create cycles
6. **Check connectivity**: Ensure all nodes are connected
7. **Return result**: Output minimum cost or "IMPOSSIBLE"

---

*This analysis shows how to efficiently find minimum spanning tree using Kruskal's algorithm with optimized Union-Find.* 